
import sys
import shutil
import os
from astropy.table import Table
from pandas import DataFrame
import numpy as np
from astropy.io import fits
from glob import glob

from analysis.paths import fourteenB_HI_data_path

'''
Run Diskfit provided with the parameter file and the path to the data.
The output is saved in the data path
'''

param_file = sys.argv[1]
data_path = sys.argv[2]

# Due to the 100 character limit, copy the parameter file into the data path
shutil.copyfile(param_file,
                os.path.join(data_path, os.path.basename(param_file)))

# Now move to data_path
os.chdir(data_path)
# Cut to just the filename
param_file = os.path.basename(param_file)

# Now extract the output filename to create the folder
with open(param_file) as f:
    content = f.readlines()

# Output is on 8th line
output_folder = content[7].split("'")[1].split("/")[0]

try:
    os.mkdir(output_folder)
except OSError:
    raise OSError("Folder name already exists.")

# Now we're ready to run it!
os.system('echo "' + param_file + '" | ~/DiskFit')

# When it finishes, move the parameter file into the output
shutil.move(param_file, output_folder)

os.chdir(output_folder)

# Now we need to: 1) add WCS information to the model FITS, and 2) make an
# easy to read version of the velocity curve.


# While thorough, the DISKFIT output isn't immediately machine-readable by
# pandas or astropy.table. This creates a more convenient output.

# Read in as a string
with open('rad.out') as f:
    contents = f.readlines()

# Read out the best fit values for the galaxy parameters and the fit results
# Params on line 39-42, 44, 56-59
params = {}
params["PA"] = float(contents[39].split()[-3])
params["PA_err"] = float(contents[39].split()[-1])
params["eps"] = float(contents[40].split()[-3])
params["eps_err"] = float(contents[40].split()[-1])
params["inc"] = float(contents[41].split()[-3])
params["inc_err"] = float(contents[41].split()[-1])
# Both x and y are on the same line
params["xcent"] = float(contents[42].split()[-6])
params["xcent_err"] = float(contents[42].split()[-4][:-1])
params["ycent"] = float(contents[42].split()[-3])
params["ycent_err"] = float(contents[42].split()[-1])
params["Vsys"] = float(contents[44].split()[-3])
params["Vsys_err"] = float(contents[44].split()[-1])

params["points_used"] = float(contents[56].split()[-1])
params["iterations"] = float(contents[57].split()[-1])
params["chi^2"] = float(contents[58].split()[-1])
params["DOF"] = float(contents[59].split()[-1])

# Can't read a dictionary directly into an astropy table?
df = DataFrame(params, index=[0])
df.to_csv('rad.out.params.csv')

# Column names are always on line 62, and data starts on 64
colnames = contents[62].split()

data = []

for line in contents[64:]:
    data.append([float(val) for val in line.split()])

data = np.array(data)
# Sometimes Vt comes out as negative.
data[:, 2] = np.abs(data[:, 2])

tab = Table(data=data, names=colnames)
tab.write('rad.out.csv')

# Add WCS info to the output of DISKFIT

fits_files = glob("*.fits")

# This is hard-coded in right now to correct the header outputted by Diskfit
mom1 = \
    fits.open(fourteenB_HI_data_path("M33_14B-088_HI.clean.image.pbcov_gt_0.3.ellip_mask.mom1.fits"))
header = mom1[0].header.copy()
mom1.close()

header["COMMENT"] = "FILE GENERATED BY DISKFIT"
keep_keys = ['INFILE', 'OUTPFILE', 'COMPS', 'SMAF', 'PIXSCALE', 'XCENOUT',
             'YCENOUT', 'PA_OUT', 'EPS_OUT']

for f in fits_files:
    new_header = header.copy()
    hdu = fits.open(f, mode='update')

    for key in keep_keys:
        new_header[key] = hdu[0].header[key]

    hdu[0].header = new_header
    hdu.flush()
    hdu.close()
